/*
 * Copyright (c) Splendid Data Product Development B.V. 2020 - 2024
 *
 * This program is free software: You may redistribute and/or modify under the terms of the GNU General Public License
 * as published by the Free Software Foundation, either version 3 of the License, or (at Client's option) any later
 * version.
 *
 * This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied
 * warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License along with this program. If not, Client should
 * obtain one via www.gnu.org/licenses/.
 */

package com.splendiddata.sqlparser.grammartojava;

import java.io.File;
import java.io.FileNotFoundException;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.ObjectOutputStream;
import java.io.PrintWriter;
import java.io.StringWriter;
import java.io.UnsupportedEncodingException;
import java.nio.file.FileVisitResult;
import java.nio.file.FileVisitor;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.nio.file.attribute.BasicFileAttributes;
import java.util.LinkedList;
import java.util.Queue;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

import org.apache.maven.plugin.AbstractMojo;
import org.apache.maven.plugin.MojoExecutionException;
import org.apache.maven.plugin.MojoFailureException;
import org.apache.maven.plugin.logging.Log;
import org.apache.maven.plugins.annotations.Execute;
import org.apache.maven.plugins.annotations.LifecyclePhase;
import org.apache.maven.plugins.annotations.Mojo;
import org.apache.maven.plugins.annotations.Parameter;

/**
 * This maven plugin picks up the Java code that is generated by Bison from the grammar that is converted by
 * {@link com.splendiddata.sqlparser.grammartojava.GrammarConverter} and converts it in a compilable source.
 * <p>
 * The challenges to overcome were:
 * </p>
 * <ul>
 * <li>Bison generates type casts that are not compatible with the Java class hierarchies. So many type casts are
 * overwritten.</li>
 * <li>The yyaction method generated more bytecode than the 64kB that the Java compiler maximally allows for a single
 * method. This problem is solved by cutting the method in several methods.</li>
 * <li>The static initializer also generated more than 64kB bytecode. That is solved by serializing the content of some
 * very big arrays to eternal files.</li>
 * </ul>
 *
 * @author Splendid Data Product Development B.V.
 * @since 0.0.1
 */
@Mojo(name = "convertJava", defaultPhase = LifecyclePhase.PROCESS_RESOURCES)
@Execute(goal = "convertJava", phase = LifecyclePhase.PROCESS_RESOURCES)
public class JavaParserConverter extends AbstractMojo implements FileVisitor<Path> {
    private Log log;

    /**
     * All code lines before the package statement are to be buffered as the directory structure of the class file needs
     * the package statement. This pattern is used to find the package statement.
     * <p>
     * on match, group(1) will contain the package name.
     * </p>
     */
    private static final Pattern PACKAGE_PATTERN = Pattern.compile("\\s*package\\s*(\\S*)\\s*;.*");

    /**
     * Pattern to find the class name.
     * <p>
     * On match, group(1) will contain the class name.
     */
    private static final Pattern CLASS_PATTERN = Pattern.compile("\\s*public\\s*class\\s*(\\w*).*");

    private static final Pattern BISON_VERSION_PATTERN = Pattern
            .compile("\\s*public static final String bisonVersion = \"([\\d.]+)\".*");

    /**
     * In the java file that is generated by Bison, tokens are always preceded by a comment line line " /** Token".
     * Tokens are to be extracted into a separate enum. This pattern is to recognise that a token definition is about to
     * be defined.
     */
    private static final Pattern TOKEN_COMMENT_PATERN = Pattern.compile("\\s*/\\*\\* Token.*");

    /**
     * Tokens are to be extracted into a separate enum. This pattern, preceded by a line that matches the
     * TOKEN_COMMENT_PATTERN recognises a token definition.
     * <p>
     * On match, group(1) contains the token name and group(2) its number.
     */
    private static final Pattern TOKEN_DEFINITION_PATTERN = Pattern
            .compile("\\s*(?:public )?static final int (\\w+) = (\\d+);");

    /**
     * The yyaction method, which is to be split because it is far too big, consists mainly of a single switch
     * statement. That switch statement can easily be cut into several switch statements - each in it's own method that
     * is invoked by a new version of the yyaction method. But of course it must be cut at a case clause. this pattern
     * us used to find case clauses of the main switch statement.
     * <p>
     * On match, group(1) will contain the token number what this case clause was for.
     * </p>
     */
    private static final Pattern CASE_PATTERN = Pattern.compile("\\s*case\\s*(\\d*)\\s*\\:(.*)");

    /**
     * For some obscure reason Bison generates an if statement in every case clause of the main switch statement in the
     * yyaction method that verifies that the number of the case clause is the correct number. I think we can trust the
     * compiler on that, so I'll remove the overhead of checking what is already known.
     */
    private static final Pattern IF_IN_CASE_PATTERN = Pattern.compile("\\s*if \\(yyn == \\d*\\)");

    /**
     * The {@link com.splendiddata.sqlparser.grammartojava.JavaSourceReader} counts the number of {'s and the number of
     * }'s it passes in the code, to keep track of the brace level. So if the brace level = 1 then we are in the outer
     * class, and not in a method.
     */
    private static final int OUTER_CLASS_BRACE_LEVEL = 1;

    /**
     * The {@link com.splendiddata.sqlparser.grammartojava.JavaSourceReader} counts the number of {'s and the number of
     * }'s it passes in the code, to keep track of the brace level. So if the brace level = 2 then we are at the lowest
     * brace level within a method in the outer class (or at the highest level in an inner class, but that has no
     * relevance here).
     */
    private static final int OUTER_CLASS_IN_FUNCTION_BRACE_LEVEL = 2;

    /**
     * Pattern to be used to compress consequtive empty ines into a single empty line.
     */
    private static final Pattern EMPTY_LINE_PATTERN = Pattern.compile("\\s*");

    /**
     * The huge arrays at the end of the source file consist of vast amount of integers, which may be negative. This
     * pattern is used to recognise all these numbers and serialize them in separate classes - which will be
     * deserialized in the static constructor.
     */
    private static final Pattern NUMERIC_SPLIT_PATTERN = Pattern.compile("[\\D&&[^-]]+");

    /**
     * Large integer arrays consist of lines with comma separated integer values according to this pattern:
     */
    private static final Pattern INTEGER_ARRAY_CONTENT_LINE = Pattern
            .compile("\\s*\\,?\\s*\\-?\\d+(\\s*\\,\\s*\\-?\\d+)*\\,?");

    /**
     * While interpreting the huge arrays at the end of the source i order to externalise them, intermediate arrays are
     * used. The ARRAY_BUFFER_SIZE defines the size of these intermediate arrays.
     */
    private static final int ARRAY_BUFFER_SIZE = 2048;

    /**
     * While cutting the yyaction method into pieces, LINES_PERCUB_BLOCK determines after how many lines in the main
     * switch statements we are going to look for the next case clause. That case clause will be the point where the
     * curent method will b finished and an new one will be started.
     */
    private static final int LINES_PER_SUB_BLOCK = 500;

    /**
     * The directory that contains the java file that is generated by Bison, and that will be used sor input.
     */
    @Parameter(property = "sourceDir", defaultValue = "target/generated_sources/converted.grammar")
    private String sourceDir;

    /**
     * The directory in which the output file will be generated
     */
    @Parameter(property = "targetDir", defaultValue = "target/generated_sources/converted.java")
    private String targetDir;

    /**
     * The directory where the externalised arrays will go
     */
    @Parameter(property = "project.build.directory")
    private String buildDirectory;

    /**
     * The Bison version that generated the parser source file
     */
    private BisonVersion bisonVersion = BisonVersion.BISON_VERSION_2;

    /**
     * Section of the source file that we are currently in
     */
    private JavaConverterPhase phase;

    /**
     * Sequence number of yyaction method part.
     */
    private int subMethodNr;

    /**
     * Line count within the main switch statement of a yyaction submethod, that is used to check that the method does
     * not get to big. If this count passes {@link #LINES_PER_SUB_BLOCK}, the current submethod is finished when the
     * next case clause is found and a new submethod is started.
     */
    private int subMethodLineCount;

    /**
     * Keeps track of the number in the case clause of the main switch statement of the yyaction method so the newly
     * generated yyaction method will be able to delegate execution to the right submethod.
     */
    private Queue<String> lastCaseInBlock = new LinkedList<>();

    /**
     * The package name of the class to be generated. This will be found in the input java file, that is generated by
     * Bison.
     */
    private String packageName = "";

    /**
     * Directory where java source files are to be generated. This will be the output directory as specified in the
     * Maven parameter extended with the package name.
     */
    private String packageDir;

    /**
     * The class name of the java class that is to be converted. It is found in the Bison generated java file.
     */
    private String className;

    /**
     * Class name of the generated token enum. This will be className + "Token".
     */
    private String tokenClassName;

    /**
     * Is set when {@link #TOKEN_COMMENT_PATERN} matches and reset on the next line.
     */
    private boolean nextLineIsToken = false;

    /**
     * @see org.apache.maven.plugin.Mojo#execute()
     */
    @Override
    public void execute() throws MojoExecutionException, MojoFailureException {
        log = getLog();
        log.info(getClass().getName() + ".execute()");
        log.info("sourceDir =\"" + sourceDir + "\"");
        log.info("targetDir =\"" + targetDir + "\"");

        try {
            Files.createDirectories(Paths.get(targetDir));
            Files.walkFileTree(Paths.get(sourceDir), this);
        } catch (IOException e) {
            log.error(e.toString(), e);
        }
    }

    /**
     * Processes the input file.
     * 
     * @see java.nio.file.FileVisitor#visitFile(java.lang.Object, java.nio.file.attribute.BasicFileAttributes)
     *
     * @return FileVisitResult.CONTINUE
     */
    @Override
    public FileVisitResult visitFile(Path file, BasicFileAttributes attrs) throws IOException {
        if (log.isDebugEnabled()) {
            log.debug("@>visitFile(file=" + file + ", attrs=" + attrs + ")");
        }

        String eofToken = "EOF";
        
        phase = JavaConverterPhase.DETERMINING_CLASS_NAME;
        try (JavaSourceReader in = new JavaSourceReader(file);
                PrintWriter out = initClassFile(in, file.toFile().getName());
                PrintWriter tokenEnum = createTokenEnumFile()) {
            for (String line = in.readLine(); line != null; line = in.readLine()) {
                switch (phase) {
                case IN_YYACTION:
                    divideYYAction(line, in, out);
                    continue;
                case IN_LARGE_TABLE_SECTION:
                    if (line.contains("yytable_[]")  // pre-bison 3.6.0
                            || line.contains("[] yytable_")) {
                        externalizeBigArrayOfShort("yytable_", in, out);
                        continue;
                    } else if (line.contains("yycheck_[] =")  // pre-bison 3.6.0
                            || line.contains("[] yycheck_")) {
                        externalizeBigArrayOfShort("yycheck_", in, out);
                        continue;
                    } else if (line.contains("yystos_[] =")  // pre-bison 3.6.0
                            || line.contains("[] yystos_")) {
                        externalizeBigArrayOfShort("yystos_", in, out);
                        continue;
                    } else if (line.contains("yydefact_[] =")  // pre-bison 3.6.0
                            || line.contains("[] yydefact_")) {
                        externalizeBigArrayOfShort("yydefact_", in, out);
                        continue;
                    } else if (line.contains("yypgoto_[] =")  // pre-bison 3.6.0
                            || line.contains("[] yypgoto_")) {
                        externalizeBigArrayOfShort("yypgoto_", in, out);
                        continue;
                    } else if (line.contains("yydefgoto_[] =")  // pre-bison 3.6.0
                            || line.contains("[] yydefgoto_")) {
                        externalizeBigArrayOfShort("yydefgoto_", in, out);
                        continue;
                    } else if (line.contains("yytoken_number_[] =")  // pre-bison 3.6.0
                            || line.contains("[] yytoken_number_")) {
                        externalizeBigArrayOfShort("yytoken_number_", in, out);
                        continue;
                    } else if (line.contains("yyr1_[] =")  // pre-bison 3.6.0
                            || line.contains("[] yyr1_")) {
                        externalizeBigArrayOfShort("yyr1_", in, out);
                        continue;
                    } else if (line.contains("yyrhs_[] =")  // pre-bison 3.6.0
                            || line.contains("[] yyrhs_")) {
                        externalizeBigArrayOfShort("yyrhs_", in, out);
                        continue;
                    } else if (line.contains("yyprhs_[] =")  // pre-bison 3.6.0
                            || line.contains("[] yyprhs_")) {
                        externalizeBigArrayOfShort("yyprhs_", in, out);
                        continue;
                    } else if (line.contains("yyrline_[] =")  // pre-bison 3.6.0
                            || line.contains("[] yyrline_")) {
                        externalizeBigArrayOfShort("yyrline_", in, out);
                        continue;
                    } else if (line.contains("yytranslate_table_[] =")  // pre-bison 3.6.0
                            || line.contains("[] yytranslate_table_")) {
                        externalizeBigArrayOfShort("yytranslate_table_", in, out);
                        continue;
                    } else if (in.getBraceLevelAtLineEnd() > 0) {
                        out.println(line);
                    } else {
                        phase = JavaConverterPhase.IN_TRAILER_SECTION;
                    }
                    continue;
                default:
                    if (line.matches("^\\s*public\\s+(static\\s+)?class\\s+Location.*")) { // Bison 3.6.0 added "static" to the class definition
                        /*
                         * Skip the entire location class. It is defined external.
                         */
                        do {
                            in.readLine();
                        } while (in.getBraceLevelAtLineEnd() > OUTER_CLASS_BRACE_LEVEL && !in.isEof());
                        continue;
                    }
                    if (line.matches("^\\s*private\\s+int\\s+yyaction\\s*\\(int\\s+yyn,\\s*YYStack\\s+yystack,\\s*int\\s+yylen\\).*")) {
                        phase = JavaConverterPhase.IN_YYACTION;
                        initYYAction(in, out);
                        continue;
                    }
                    if (line.contains("yypact_[] =") // pre bison 3.6.0
                            || line.contains("[] yypact_ =")) {
                        phase = JavaConverterPhase.IN_LARGE_TABLE_SECTION;
                        initBigArraySection(out);
                        externalizeBigArrayOfInt("yypact_", in, out);
                        continue;
                    }
                    break;
                }
                if (nextLineIsToken) {
                    Matcher matcher = TOKEN_DEFINITION_PATTERN.matcher(line);
                    if (matcher.matches()) {
                        String tokenName = matcher.group(1);
                        switch (tokenName) {
                        case "EOF":
                        case "YYEOF": // The EOF keyword has been replaced by YYEOF in Bison 3.6.0
                            eofToken = tokenName;
                            /*
                             * The EOF token is the first token, and is used in the parser as well. So it must be
                             * written to both the parser class file as the enum file.
                             */
                            out.println(line);
                            break;
                        case "COLUMN":
                        case "YYUNDEF": // In use since Bison 3.6.0
                            /*
                             * COLUMN is used in the parser as well. This is not the first token, so a comma must be
                             * added to finish the prior token definition.
                             */
                            tokenEnum.println(",");
                            out.println(line);
                            break;
                        default:
                            /*
                             * This is not the first token, so a comma must be added to finish the prior token
                             * definition.
                             */
                            tokenEnum.println(",");
                        }
                        tokenEnum.print("    ");
                        tokenEnum.print(tokenName);
                        tokenEnum.print("(");
                        tokenEnum.print(matcher.group(2));
                        tokenEnum.print(")");
                        nextLineIsToken = false;
                        continue;
                    }
                } else {
                    if (TOKEN_COMMENT_PATERN.matcher(line).matches()) {
                        nextLineIsToken = true;
                        continue;
                    }
                }
                out.println(performStandardReplacements(line));
                nextLineIsToken = false;
            }
            out.println("}");

            finishTokenEnumFile(tokenEnum, eofToken);
        }

        if (log.isDebugEnabled()) {
            log.debug("@<visitFile(file=" + file + ", attrs=" + attrs + ") = CONTINUE");
        }
        return FileVisitResult.CONTINUE;
    }

    /**
     * performs some standard replacements in every line. Mainly class casts are overridden here.
     *
     * @param line
     *            The input line
     * @return String the converted line
     */
    private static String performStandardReplacements(String line) {
        return line
                /*
                 * yyval is an Object, so doesn't need type cast. Type casts of elements to yyval give trouble because C
                 * has quite different opinions on which types can be cast to each other than Java, so let's remove
                 * them.
                 */
                .replaceAll("yyval\\s*=\\s*\\(\\([^()]*\\)", "yyval = (")
                /*
                 * Although, if an intValue is taken from it, the type cast was necessary after all.
                 */
                .replaceAll("(\\s*)\\(\\((\\()?yystack.valueAt(.*?)\\.intValue",
                        "$1(((Integer)$2yystack.valueAt$3.intValue")
                /*
                 * The same goes for expected Boolean values
                 */
                .replaceAll("yyval = \\(\\(yystack(.*?)\\s*\\?", "yyval = ((Boolean)(yystack$1.booleanValue() ?")
                /*
                 * CmdType is not an integer but an enum
                 */
                .replaceAll("\\.event\\s*=\\s*\\(\\s*\\(\\s*Integer", ".event = ((CmdType")
                /*
                 * and range means the class RangeVar
                 */
                .replaceAll("\\(\\s*range\\s*\\)", "(RangeVar)")
                /*
                 * fun_param is short for FunctionParameter
                 */
                .replaceAll("\\(\\s*fun_param\\s*\\)", "(FunctionParameter)")
                /*
                 * Who qould have guessed: defelt translates to DefElem whatever that may be)
                 */
                .replaceAll("\\(\\s*defelt\\s*\\)", "(DefElem)")
                /*
                 * who would have guessed that by a class cast to Iconst in fact a class cast to TypeName was meant?
                 */
                .replaceAll("\\(\\s*Iconst\\s*\\)", "(TypeName)")
                /*
                 * {@link com.splendiddata.sqlparser.structure.ViewStmt#withCheckOption} is not an Integer but a
                 * ViewCheckOption
                 */
                .replaceAll("(n.withCheckOption = \\(\\()Integer", "$1ViewCheckOption")
                /*
                 * Java does not support indirections. So the result of a method can never be assigned a value. So a
                 * trick is to be performed to assing a value directly to the yystack.valueStack
                 */
                .replaceAll("\\(\\(\\w*\\)\\(yystack.valueAt\\s*(\\(\\w*-\\(\\w*\\)\\))\\)\\)\\s* =([^=])",
                        "yystack.valueStack[yystack.height - $1] =$2")
                /*
                 * LockWaitPolicy shouldn't hve been cast to Integer in the first place
                 */
                .replace("(LockWaitPolicy)((Integer)", "((LockWaitPolicy)")
                /*
                 * Repair the ImportForeignSchemaType cast
                 */
                .replace("(ImportForeignSchemaType)((Integer)", "((ImportForeignSchemaType)")
                /*
                 * Repair the ReindexObjectType cast
                 */
                .replace("(ReindexObjectType)((Integer)", "((ReindexObjectType)");
    }

    /**
     * The yyaction in the java class that is generated by Bison compiles to over 64kB of bytecode. This is not allowed
     * by the java compiler. so we will cut it into a bunch of smaller methods, called yyaction_1 ... yy_action_nn. The
     * yyaction method itself will be rewritten to invoke the yyaction_n methods.
     * <p>
     * Cutting the method into pieces is not that hard as it consists mainly of a huge switch statement, which can
     * easily be cut on case clauses.
     * </p>
     *
     * @param line
     *            The current input line
     * @param in
     *            The JavaSourceReader that will provide following lines
     * @param out
     *            The generated output file to which to add yyaction_nn() methods
     * @throws IOException
     *             if anything goes wrong
     */
    private void divideYYAction(String line, JavaSourceReader in, PrintWriter out) throws IOException {
        if (in.getBraceLevelAtLineEnd() == OUTER_CLASS_IN_FUNCTION_BRACE_LEVEL) {
            lastCaseInBlock.add(String.valueOf(Integer.MAX_VALUE));
            finishYYActionBlock(out);
            finishYYAction(in, out);
        }
        if (IF_IN_CASE_PATTERN.matcher(line).matches()) {
            return;
        }
        if (EMPTY_LINE_PATTERN.matcher(line).matches() && EMPTY_LINE_PATTERN.matcher(in.getPriorLine()).matches()) {
            /*
             * Remove an empty line after an empty line or after a break
             */
            return;
        }
        if (subMethodLineCount > LINES_PER_SUB_BLOCK) {
            Matcher matcher = CASE_PATTERN.matcher(line);
            if (matcher.matches()) {
                lastCaseInBlock.add(matcher.group(1));
                finishYYActionBlock(out);
                initYYActionBlock(out);
            }
        }
        String convertedLine;
        if (line.startsWith("/*")) {
            convertedLine = "    " + line;
        } else if (line.startsWith("  break;")) {
            convertedLine = "  " + line;
        } else {
            convertedLine = performStandardReplacements(line);
        }
        out.println(convertedLine);
        subMethodLineCount++;
    }

    /**
     * Finds the main switch statement in the yyaction method. All code before tht statement in the yyaction method is
     * skipped - it will be generated in every yyaction_nn method.
     *
     * @param in
     *            The reader that will provide source lines
     * @param out
     *            The writer to which to write output to
     * @throws IOException
     *             from the reader or the writer
     */
    private void initYYAction(JavaSourceReader in, PrintWriter out) throws IOException {
        do {
            in.readLine();
        } while (!"    switch (yyn)".equals(in.getPriorLine()));

        subMethodNr = 0;
        initYYActionBlock(out);
    }

    /**
     * Starts a new yyaction_n method
     *
     * @param out
     *            The generated source file to append to
     */
    private void initYYActionBlock(PrintWriter out) {
        subMethodLineCount = 0;
        bisonVersion.initYYActionBlock(out, subMethodNr++);
    }

    /**
     * Finishes a yyaction_n method
     *
     * @param out
     *            The PrintWriter that will receive the end of the yyaction_n method
     */
    private void finishYYActionBlock(PrintWriter out) {
        bisonVersion.finishYYActionBlock(out);
    }

    /**
     * We have reached the end of the original yyaction method. Here we will create a new one that delegates execution
     * to one of the generated yyaction_nn methods. The remaining part of the original method is skipped.
     *
     * @param in
     *            Provides input lines
     * @param out
     *            Receives output lines
     * @throws IOException
     *             From the reader or the writer
     */
    private void finishYYAction(JavaSourceReader in, PrintWriter out) throws IOException {
        out.println("  private int yyaction (int yyn, YYStack yystack, int yylen) {");
        for (int i = 0; i < subMethodNr; i++) {
            out.print("    if (yyn < ");
            out.print(lastCaseInBlock.poll());
            out.println(") {");
            out.print("      return yyaction_");
            out.print(i);
            out.println("(yyn, yystack, yylen);");
            out.println("    }");
        }
        out.println("    return 0;");
        out.println();

        /*
         * Skip the remaining part of the original yyaction method
         */
        do {
            in.readLine();
        } while (in.getBraceLevelAtLineEnd() > OUTER_CLASS_BRACE_LEVEL && !in.isEof());

        phase = JavaConverterPhase.NORMAL_PROCESSING;
    }

    /**
     * Buffers the read input until a package name is found. Then the output file is created and the heading including
     * the package name definition is written to it. The writer for the just created file is returned.
     *
     * @param reader
     *            Reads the input source file
     * @param classFileName
     *            File name that might be used in an exception
     * @return PrintWriter The output file containing the class header
     * @throws IOException
     *             In case of an error
     */
    @SuppressWarnings({ "resource", "null" })
    private PrintWriter initClassFile(JavaSourceReader reader, String classFileName) throws IOException {
        StringWriter buffer = new StringWriter();
        PrintWriter writer = new PrintWriter(buffer);
        PrintWriter out = null;

        for (String line = reader.readLine(); line != null; line = reader.readLine()) {
            Matcher matcher = PACKAGE_PATTERN.matcher(line);
            if (matcher.matches()) {
                packageName = matcher.group(1);
            } else {
                matcher = CLASS_PATTERN.matcher(line);
                if (matcher.matches()) {
                    className = matcher.group(1);
                    /*
                     * A class definition is found. Let's create the class file.
                     */
                    packageDir = targetDir;
                    if (!packageName.isEmpty()) {
                        packageDir = packageDir + File.separator + packageName.replace('.', File.separatorChar);
                    }
                    Files.createDirectories(Paths.get(packageDir));
                    out = new PrintWriter(new File(packageDir, className + ".java"), "UTF-8");
                    writer.close();
                    out.append(buffer.toString());
                    out.println(line);
                    break;
                }
            }
            if (log.isDebugEnabled()) {
                log.debug("buffer: " + line);
            }
            writer.println(line);
        }

        for (String line = reader.readLine(); line != null; line = reader.readLine()) {
            out.println(line);
            Matcher matcher = BISON_VERSION_PATTERN.matcher(line);
            if (matcher.matches()) {
                bisonVersion = BisonVersion.fromVersionString(matcher.group(1));
                if (bisonVersion == null) {
                    bisonVersion = BisonVersion.BISON_VERSION_2;
                    log.warn(new StringBuilder().append("Bison version \"").append(matcher.group(1))
                            .append("\" in line \"").append(line)
                            .append("\" cannot be interpreted as a usable bison version. Version: ")
                            .append(bisonVersion).append(" assumed."));
                } else {
                    log.info("Bison version = " + bisonVersion);
                }
                return out;
            }
        }

        throw new IOException(classFileName
                + " is not a Bison generated class file - no package name or class name or bisonVersion found.");
    }

    /**
     * Creates and initialises the class file for the token enum, using the parser class's package name with the class
     * name of the parser extended with "Token".
     *
     * @return PrintWriter The token enum file containing the class header.
     * @throws UnsupportedEncodingException
     *             from the PrintWriter
     * @throws FileNotFoundException
     *             Shouldn't hapen
     */
    private PrintWriter createTokenEnumFile() throws FileNotFoundException, UnsupportedEncodingException {
        tokenClassName = "ScanKeyword";
        PrintWriter tokenEnum = new PrintWriter(new File(packageDir, tokenClassName + ".java"), "UTF-8");
        if (!packageName.isEmpty()) {
            tokenEnum.print("package ");
            tokenEnum.print(packageName);
            tokenEnum.println(";");
            tokenEnum.println();
        }
        tokenEnum.println("import java.util.Collections;");
        tokenEnum.println("import java.util.HashMap;");
        tokenEnum.println("import java.util.Map;");
        tokenEnum.println();
        tokenEnum.println("import com.splendiddata.sqlparser.enums.Keyword;");
        tokenEnum.println();
        tokenEnum.println("/**");
        tokenEnum.print(" * Contains all tokens for ");
        if (!packageName.isEmpty()) {
            tokenEnum.print(packageName);
            tokenEnum.print(".");
        }
        tokenEnum.print(className);
        tokenEnum.println(".");
        tokenEnum.print(" * <p>This file is generated by ");
        tokenEnum.print(getClass().getName());
        tokenEnum.println(".");
        tokenEnum.println(" * Don't change it.</p>");
        tokenEnum.println(" */");
        tokenEnum.print("public enum ");
        tokenEnum.print(tokenClassName);
        tokenEnum.println(" {");
        return tokenEnum;
    }

    /**
     * Writes a trailer after the token definitions int the token enum file.
     *
     * @param tokenEnum
     *            The generated ScanKeyword.java file under construction
     * @param eofToken 
     */
    private void finishTokenEnumFile(PrintWriter tokenEnum, String eofToken) {
        tokenEnum.println(";");
        tokenEnum.println();
        if (!"EOF".equals(eofToken)) {
            tokenEnum.println("    /**");
            tokenEnum.print("     * Synonym for {@link #");
            tokenEnum.print(eofToken);
            tokenEnum.println("} for backward compatibility");
            tokenEnum.println("     */");
            tokenEnum.print("    public static final ");
            tokenEnum.print(tokenClassName);
            tokenEnum.print(" EOF = ");
            tokenEnum.print(eofToken);
            tokenEnum.println(";");
            tokenEnum.println();
        }
        tokenEnum.print("    private static final Map<String, ");
        tokenEnum.print(tokenClassName);
        tokenEnum.println("> FROM_NAME;");
        tokenEnum.println();
        tokenEnum.print("    private static final ");
        tokenEnum.print(tokenClassName);
        tokenEnum.println("[] FROM_INT;");
        tokenEnum.println();
        tokenEnum.println("    /**");
        tokenEnum.println("     * The token value");
        tokenEnum.println("     */");
        tokenEnum.println("    public final int value;");
        tokenEnum.println();
        tokenEnum.println("    /**");
        tokenEnum.println("     * The name in lower case");
        tokenEnum.println("     */");
        tokenEnum.println("    public final String name;");
        tokenEnum.println();
        tokenEnum.println("    /**");
        tokenEnum.println("     * The category");
        tokenEnum.println("     */");
        tokenEnum.println("    public final int category;");
        tokenEnum.println();
        tokenEnum.print("    private ");
        tokenEnum.print(tokenClassName);
        tokenEnum.println("(int token) {");
        tokenEnum.println("        value = token;");
        tokenEnum.println("        for (Keyword kw : Keyword.values()) {");
        tokenEnum.println("            if (kw.name().equals(name())) {");
        tokenEnum.println("                this.name = kw.name;");
        tokenEnum.println("                this.category = kw.category;");
        tokenEnum.println("                return;");
        tokenEnum.println("            }");
        tokenEnum.println("        }");
        tokenEnum.println("        this.name = name().toLowerCase().replaceAll(\"^(\\\\w+?)_p$\", \"$1\");");
        tokenEnum.println("        this.category = 0;");
        tokenEnum.println("    }");
        tokenEnum.println();
        tokenEnum.println("    /**");
        tokenEnum.println("     * Returns this keyword's value");
        tokenEnum.println("     *");
        tokenEnum.println("     * @return int value");
        tokenEnum.println("     */");
        tokenEnum.println("    public int getValue() {");
        tokenEnum.println("        return value;");
        tokenEnum.println("    }");
        tokenEnum.println();
        tokenEnum.println("    /**");
        tokenEnum.println(
                "     * Returns this keyword's name. Note that this is a name given by Postgres in all lower case.");
        tokenEnum.println("     * The returned name is something else than what Enum.name() would return.");
        tokenEnum.println("     *");
        tokenEnum.println("     * @return String name");
        tokenEnum.println("     */");
        tokenEnum.println("    public String getName() {");
        tokenEnum.println("        return name;");
        tokenEnum.println("    }");
        tokenEnum.println();
        tokenEnum.println("    /**");
        tokenEnum.println("     * Returns this keyword's category");
        tokenEnum.println("     *");
        tokenEnum.println("     * @return int category");
        tokenEnum.println("     */");
        tokenEnum.println("    public int getCategory() {");
        tokenEnum.println("        return category;");
        tokenEnum.println("    }");
        tokenEnum.println();
        tokenEnum.println("    /**");
        tokenEnum.print("     * Returns the ");
        tokenEnum.print(tokenClassName);
        tokenEnum.println(" value that belongs to the name or null if not found.");
        tokenEnum.println("     *");
        tokenEnum.print("     * @return ");
        tokenEnum.print(tokenClassName);
        tokenEnum.println(" The value that is found by the specified string");
        tokenEnum.println("     */");
        tokenEnum.print("    public static ");
        tokenEnum.print(tokenClassName);
        tokenEnum.println(" fromName(String string) {");
        tokenEnum.print("        return FROM_NAME.get(string.toLowerCase());");
        tokenEnum.println("    }");
        tokenEnum.println();
        tokenEnum.println("    /**");
        tokenEnum.print("     * Returns the ");
        tokenEnum.print(tokenClassName);
        tokenEnum.println(" value with the specified token or null if not found.");
        tokenEnum.println("     *");
        tokenEnum.print("     * @return ");
        tokenEnum.print(tokenClassName);
        tokenEnum.println(" The ScanKeyword that is found by the specified value or null if not found");
        tokenEnum.println("     */");
        tokenEnum.print("    public static ");
        tokenEnum.print(tokenClassName);
        tokenEnum.println(" fromValue(int value) {");
        tokenEnum.println("        if (value < 0 || value >= FROM_INT.length) {");
        tokenEnum.println("            return null;");
        tokenEnum.println("        }");
        tokenEnum.println("        return FROM_INT[value];");
        tokenEnum.println("    }");
        tokenEnum.println();
        tokenEnum.println("    static {");
        tokenEnum.println("        int maxValue = 0;");
        tokenEnum.print("        Map<String, ");
        tokenEnum.print(tokenClassName);
        tokenEnum.print("> map = new HashMap<>(");
        tokenEnum.print(tokenClassName);
        tokenEnum.println(".values().length * 10 / 7);");
        tokenEnum.print("        for (");
        tokenEnum.print(tokenClassName);
        tokenEnum.print(" kw : ");
        tokenEnum.print(tokenClassName);
        tokenEnum.println(".values()) {");
        tokenEnum.println("            map.put(kw.name, kw);");
        tokenEnum.println("            if (kw.value > maxValue) {");
        tokenEnum.println("                maxValue = kw.value;");
        tokenEnum.println("            }");
        tokenEnum.println("        }");
        tokenEnum.println("        FROM_NAME = Collections.unmodifiableMap(map);");
        tokenEnum.println();
        tokenEnum.print("        FROM_INT = new ");
        tokenEnum.print(tokenClassName);
        tokenEnum.println("[maxValue + 1];");
        tokenEnum.print("        for (");
        tokenEnum.print(tokenClassName);
        tokenEnum.print(" kw : ");
        tokenEnum.print(tokenClassName);
        tokenEnum.println(".values()) {");
        tokenEnum.println("            FROM_INT[kw.value] = kw;");
        tokenEnum.println("        }");
        tokenEnum.println("    }");
        tokenEnum.println("}");
    }

    /**
     * We found the first big array that needs to be externalized in the source file. Here we'll insert the readArray
     * method, that will help deserializing the big arrays and we will created the directory structure where the big
     * arrays will be serialized.
     *
     * @param out
     *            The generated source file to which to write the readArray(String) method
     */
    private void initBigArraySection(PrintWriter out) {
        File outputFile = new File(buildDirectory + File.separator + "classes" + File.separator + "arrays");
        outputFile.mkdirs();

        out.println();
        out.println("  private static final <_T> _T readArray(String tableName) {");
        out.println("    try (InputStream is = " + className + ".class.getResourceAsStream(\"/arrays/\" + tableName);");
        out.println("      ObjectInputStream ois = new ObjectInputStream(is)) {");
        out.println("      Object result = ois.readObject();");
        out.println("/* Enable for debugging purposes: ");
        out.println(" *    if (result instanceof short[]) {");
        out.println(" *        System.out.println(tableName + \" has \" + ((short[])result).length + \" entries\");");
        out.println(" *    } else if (result instanceof short[]) {");
        out.println(" *        System.out.println(tableName + \" has \" + ((int[])result).length + \" entries\");");
        out.println(" *    }");
        out.println(" */");
        out.println("      return (_T) result;");
        out.println("    } catch (Exception e) {");
        out.println("      System.err.println(\"readShortArray(tableName=\" + tableName + \")->failed\");");
        out.println("      e.printStackTrace(System.err);");
        out.println("      throw new RuntimeException(\"readShortArray(tableName=\" + tableName + \")->failed\", e);");
        out.println("    }");
        out.println("  }");
        out.println();
    }

    /**
     * Creates a short[] from the source file and serializes it in a new file that uses the arrayName as file name. The
     * generated file will be read by the static initializer that is inserted in the array definition.
     *
     * @param arrayName
     *            Name of the array that is to be serialized
     * @param in
     *            The sourc file that is to be converted
     * @param out
     *            The converted output file to which some remainders of the array definition will be written
     * @throws IOException
     *             from the reader or the writer
     */
    @SuppressWarnings("null")
    private void externalizeBigArrayOfShort(String arrayName, JavaSourceReader in, PrintWriter out) throws IOException {
        String[] split = in.getCurrentLine().split("=");
        out.print(split[0]);
        out.print("= readArray(\"");
        out.print(arrayName);
        out.println("\");");

        int braceLevel = in.getBraceLevelAtLineStart();
        String line;
        for (line = in.readLine(); line != null
                && !INTEGER_ARRAY_CONTENT_LINE.matcher(line).matches(); line = in.readLine()) {
            // Just read the lines.
        }

        Queue<short[]> list = new LinkedList<>();
        short[] chunk = null;
        int n = ARRAY_BUFFER_SIZE;
        for (; line != null && INTEGER_ARRAY_CONTENT_LINE.matcher(line).matches(); line = in.readLine()) {
            for (String next : NUMERIC_SPLIT_PATTERN.split(line)) {
                if (!"".equals(next)) {
                    if (n >= ARRAY_BUFFER_SIZE) {
                        chunk = new short[ARRAY_BUFFER_SIZE];
                        list.offer(chunk);
                        n = 0;
                    }
                    chunk[n++] = Short.parseShort(next);
                }
            }
        }

        while (in.getBraceLevelAtLineEnd() > braceLevel) {
            in.readLine();
        }

        short[] array = new short[(list.size() - 1) * ARRAY_BUFFER_SIZE + n];
        int i = 0;
        while (!list.isEmpty()) {
            chunk = list.poll();
            System.arraycopy(chunk, 0, array, i, list.isEmpty() ? n : ARRAY_BUFFER_SIZE);
            i += ARRAY_BUFFER_SIZE;
        }
        if (log.isDebugEnabled()) {
            log.debug(arrayName + " contains " + array.length + " shorts");
        }

        try (FileOutputStream fos = new FileOutputStream(
                buildDirectory + File.separator + "classes" + File.separator + "arrays" + File.separator + arrayName);
                ObjectOutputStream oos = new ObjectOutputStream(fos)) {
            oos.writeObject(array);
        }
    }

    /**
     * Creates a int[] from the source file and serializes it in a new file that uses the arrayName as file name. The
     * generated file will be read by the static initializer that is inserted in the array definition.
     *
     * @param arrayName
     *            Name of the array to externalize
     * @param in
     *            The original source file containing the (huge) array
     * @param out
     *            The target source file, to which just the array name and some initialisation code is written
     * @throws IOException
     *             From the reader or the writer
     */
    @SuppressWarnings("null")
    private void externalizeBigArrayOfInt(String arrayName, JavaSourceReader in, PrintWriter out) throws IOException {
        String[] split = in.getCurrentLine().split("=");
        out.print(split[0]);
        out.print("= readArray(\"");
        out.print(arrayName);
        out.println("\");");

        int braceLevel = in.getBraceLevelAtLineStart();
        String line;
        for (line = in.readLine(); line != null
                && !INTEGER_ARRAY_CONTENT_LINE.matcher(line).matches(); line = in.readLine()) {
            // Just read the lines.
        }

        Queue<int[]> list = new LinkedList<>();
        int[] chunk = null;
        int n = ARRAY_BUFFER_SIZE;
        for (; line != null && INTEGER_ARRAY_CONTENT_LINE.matcher(line).matches(); line = in.readLine()) {
            for (String next : NUMERIC_SPLIT_PATTERN.split(line)) {
                if (!"".equals(next)) {
                    if (n >= ARRAY_BUFFER_SIZE) {
                        chunk = new int[ARRAY_BUFFER_SIZE];
                        list.offer(chunk);
                        n = 0;
                    }
                    chunk[n++] = Integer.parseInt(next);
                }
            }
        }

        while (in.getBraceLevelAtLineEnd() > braceLevel) {
            in.readLine();
        }

        int[] array = new int[(list.size() - 1) * ARRAY_BUFFER_SIZE + n];
        int i = 0;
        while (!list.isEmpty()) {
            chunk = list.poll();
            System.arraycopy(chunk, 0, array, i, list.isEmpty() ? n : ARRAY_BUFFER_SIZE);
            i += ARRAY_BUFFER_SIZE;
        }
        if (log.isDebugEnabled()) {
            log.debug(arrayName + " contains " + array.length + " integers");
        }

        try (FileOutputStream fos = new FileOutputStream(
                buildDirectory + File.separator + "classes" + File.separator + "arrays" + File.separator + arrayName);
                ObjectOutputStream oos = new ObjectOutputStream(fos)) {
            oos.writeObject(array);
        }
    }

    /**
     * Just returns FileVisitResult.CONTINUE
     * 
     * @see java.nio.file.FileVisitor#preVisitDirectory(java.lang.Object, java.nio.file.attribute.BasicFileAttributes)
     *
     * @return FileVisitResult.CONTINUE
     */
    @Override
    public FileVisitResult preVisitDirectory(Path dir, BasicFileAttributes attrs) throws IOException {
        return FileVisitResult.CONTINUE;
    }

    /**
     * Just returns FileVisitResult.CONTINUE
     * 
     * @see java.nio.file.FileVisitor#visitFileFailed(java.lang.Object, java.io.IOException)
     *
     * @return FileVisitResult.CONTINUE
     */
    @Override
    public FileVisitResult visitFileFailed(Path file, IOException exc) throws IOException {
        return FileVisitResult.CONTINUE;
    }

    /**
     * Just returns FileVisitResult.CONTINUE
     * 
     * @see java.nio.file.FileVisitor#postVisitDirectory(java.lang.Object, java.io.IOException)
     *
     * @return FileVisitResult.CONTINUE
     */
    @Override
    public FileVisitResult postVisitDirectory(Path dir, IOException exc) throws IOException {
        return FileVisitResult.CONTINUE;
    }

}
